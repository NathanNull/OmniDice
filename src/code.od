/*let die = 3d6 + 3;
let res = {
    let dice = die + die + die; dice.mean // 3d6
};
let Bool_value = true;
let a = 4%3;
a += 1_500_000;
let b = if a < 3 {1} else if a == 2 {4} else {17};
while a > 2 {
    a -= 3;
}
printf("{}", a);*/

/*let amogus = (1,"asdf",[5.0]);
amogus.i0 += 4;
amogus.i1 += "\nbeans";
amogus.i2 += [1.,3.];
amogus.i2[0,1] = [4.,5.];
amogus*/

/*let int = ref(1);
let arr = [int];
arr[0].inner += 1;
printf("{}, {}", (int.inner, arr));*/

/*let i = ref(1);
let a = func (p1: bool, p2: int, p3: [float]) {
    i.inner += 1;
    println("amogus");
} + func(p1: int) {
    println("function overloading woooo");
};
a(false, 5, [2.6]);
a(0);
printf("Value of i: {}", i.inner);*/

// Recursion baybeeee
/*let factorial = ref(func(param: int) -> int{error("did not, in fact, do the thing.");7});
factorial.inner = func(param: int) -> int {
    if param <= 1 {
        1
    } else {
        factorial(param-1)*param
    }
};
let i = 0;
while i < 10 {
    printf("{}! = {}", (i, factorial(i)));
    i += 1;
}*/

/*let it = (1..5).iter();
for next in iter(func() -> maybe<int> {
    if (let n_opt = it.next()).filled {
        let next = n_opt.unwrap();
        filled(next * next)
    } else {
        null()
    }
}).map(func(param: int) -> int {param + param}) {
    printf("{}", next);
}*/

/*let fn = func<T,U>(p1: T, p2: U) -> T {
    p1+p2
};
typedef num = int;
let a = fn::<num, num>(1, 5);
printf("{}", a);
printf("1: {}, 2: {}, 3: {}", (1,2,3));
printf("This is computed at compile time: {}, {},\n{}", ([1,2,3], 1+2+3/4/5.0, 3d6));*/

/*let map = (0..50).iter().map(func(i: int) -> (string, int) {(format("{}", i), i)}).to_map();
map.set("456", 456);
printf("{}", map.get("12"));
printf("{}", map);

for kvp in map {
    printf("{}: {}", (kvp.i0, kvp.i1));
}*/

/*printf("{}", 2d[1,2,3,4,5,6]);
let map = (1..11).iter().map(func(i:int) -> (int, int) {(i,i)}).to_map();
printf("{}", 1d(map));*/

/*printf("{}", dicemap([d6,d6],func(ints:[int])->int{
    if ints[0] > ints[1] {ints[0]} else {ints[1]}
}))*/

/*let a = func() -> int {
    return 7;
    12
};

for i in 0..100 {
    if i % 3 == 0 {
        continue;
    }
    printf("{}, {}", (i, a()));
    if i > 10 {
        break;
    }
}*/

let v: maybe<int> = null();

v.unwrap();

//printf("{}", (0..=10).iter().filter(func(i: int) -> bool {i % 2 == 0}).fold("", func(acc: string, i: int)->string{format("{}, {}", (acc, i))}));