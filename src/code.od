/*let die = 3d6 + 3;
let res = {
    let dice = die + die + die; dice.mean // 3d6
};
let Bool_value = true;
let a = 4%3;
a += 1_500_000;
let b = if a < 3 {1} else if a == 2 {4} else {17};
while a > 2 {
    a -= 3;
}
printf("{}", a);*/

/*let amogus = (1,"asdf",[5.0]);
amogus.i0 += 4;
amogus.i1 += "\nbeans";
amogus.i2 += [1.,3.];
amogus.i2[0,1] = [4.,5.];
amogus*/

/*let int = ref(1);
let arr = [int];
arr[0].inner += 1;
printf("{}, {}", (int.inner, arr));*/

/*let i = ref(1);
let a = func (p1: bool, p2: int, p3: [float]) {
    i.inner += 1;
    println("amogus");
} + func(p1: int) {
    println("function overloading woooo");
};
a(false, 5, [2.6]);
a(0);
printf("Value of i: {}", i.inner);*/

// Recursion baybeeee
/*let factorial = ref(func(param: int) -> int{error("did not, in fact, do the thing.");7});
factorial.inner = func(param: int) -> int {
    if param <= 1 {
        1
    } else {
        factorial(param-1)*param
    }
};
let i = 0;
while i < 10 {
    printf("{}! = {}", (i, factorial(i)));
    i += 1;
}*/

/*let it = (1..5).iter();
for next in iter(func() -> maybe<int> {
    if (let n_opt = it.next()).filled {
        let next = n_opt.unwrap();
        filled(next * next)
    } else {
        null()
    }
}).map(func(param: int) -> int {param + param}) {
    printf("{}", next);
}*/

let fn = func<T,U>(p1: T, p2: U) -> T {
    p1+p2
};
typedef num = int;
let a = fn::<num, num>(1, 5);
printf("{}", a);
printf("1: {}, 2: {}, 3: {}", (1,2,3));
printf("This is computed at compile time: {}, {},\n{}", ([1,2,3], 1+2+3/4/5.0, 3d6));